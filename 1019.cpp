//1019. 数字黑洞(20)
//
//时间限制
//100 ms
//内存限制
//65536 kB
//代码长度限制
//8000 B
//判题程序
//Standard
//作者
//CHEN, Yue

//给定任一个各位数字不完全相同的4位正整数，
//如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。
//一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。
//
//例如，我们从6767开始，将得到
//
//7766 - 6677 = 1089
//9810 - 0189 = 9621
//9621 - 1269 = 8352
//8532 - 2358 = 6174
//7641 - 1467 = 6174
//... ...
//
//现给定任意4位正整数，请编写程序演示到达黑洞的过程。
//
//输入格式：
//
//输入给出一个(0, 10000)区间内的正整数N。
//
//输出格式：
//
//如果N的4位数字全相等，则在一行内输出“N - N = 0000”；
//否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。
//
//输入样例1：
//6767
//输出样例1：
//7766 - 6677 = 1089
//9810 - 0189 = 9621
//9621 - 1269 = 8352
//8532 - 2358 = 6174
//输入样例2：
//2222
//输出样例2：
//2222 - 2222 = 0000

//idea:
//这题主要问题就在于得到每轮的最大数和最小数
//然后每个输出都要按要求四位输出
//我这里使用了长度为4的数组
//一些特殊的输入要做不一样的处理：四位数字相同和6174
//我感觉我这题写的也不是很好
//用stirng的stoi和to_string应该可以简化

#include <iostream>
#include <string>
#include <array>
#include <cmath>

using namespace std;

int main()
{
	int n;
	cin >> n;
	array<int, 4> arr;
	
	if (n == 1111 || n == 2222 || n == 3333 || n == 4444 || n == 5555 || n == 6666 || n == 7777 || n == 8888 || n == 9999)
		cout << n << " - " << n << " = " << "0000";
	else if(n==6174)
		cout << 7641 << " - " << 1467 << " = " << "6174";
	else
	{
		while (n != 6174)
		{
			if (n < 10)
			{
				for (int i = 0; i != 3; ++i)
					arr[i] = 0;
				arr[3] = n;
			}
			else if (n >= 10 && n<100)
			{
				arr[0] = 0;
				arr[1] = 0;
				arr[2] = n / 10;
				arr[3] = n % 10;
			}
			else if (n >= 100 && n<1000)
			{
				arr[0] = 0;
				arr[1] = n / 100;
				arr[2] = (n - 100 * arr[1]) / 10;
				arr[3] = n % 10;
			}
			else
			{
				arr[0] = n / 1000;
				arr[1] = (n - 1000 * arr[0]) / 100;
				arr[2] = (n - 1000 * arr[0] - 100 * arr[1]) / 10;
				arr[3] = n % 10;
			}

			//这个排序也是可以用sort代替的，但这里维数为4较小就直接写了，也不会太慢
			int temp;
			for (int i = 0; i != 4; ++i)
				for (int j = i + 1; j != 4; ++j)
				{
					if (arr[j] > arr[i])
					{
						temp = arr[i];
						arr[i] = arr[j];
						arr[j] = temp;
					}
				}

			int max = 0, min = 0;
			for (int i = 0; i != 4; ++i)
			{
				cout << arr[i];
				max += static_cast<int>(pow(10, 3 - i))*arr[i];
			}
			cout << " - ";
			for (int i = 3; i != -1; --i)
			{
				cout << arr[i];
				min += static_cast<int>(pow(10, i))*arr[i];
			}
			cout << " = ";
			n = max - min;
			//输出要注意n也要按四位数输出
			if (n < 10)
			{
				for (int i = 0; i != 3; ++i)
					arr[i] = 0;
				arr[3] = n;
			}
			else if (n >= 10 && n<100)
			{
				arr[0] = 0;
				arr[1] = 0;
				arr[2] = n / 10;
				arr[3] = n % 10;
			}
			else if (n >= 100 && n<1000)
			{
				arr[0] = 0;
				arr[1] = n / 100;
				arr[2] = (n - 100 * arr[1]) / 10;
				arr[3] = n % 10;
			}
			else
			{
				arr[0] = n / 1000;
				arr[1] = (n - 1000 * arr[0]) / 100;
				arr[2] = (n - 1000 * arr[0] - 100 * arr[1]) / 10;
				arr[3] = n % 10;
			}
			for (int i = 0; i != 4; ++i)
			{
				cout << arr[i];
			}
			cout << endl;
		}
	}
}